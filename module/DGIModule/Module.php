<?phpnamespace DGIModule;use Detection\MobileDetect;use DGIModule\Navigation\DGINavigation;use DGIModule\View\Helper\ConfigItem;use DGIModule\View\Helper\CurrentRequest;use Doctrine\DBAL\Types\Type;use Zend\Log\Writer\Stream;use Zend\ModuleManager\Feature\AutoloaderProviderInterface;use Zend\ModuleManager\Feature\ConfigProviderInterface;use Zend\ServiceManager\ServiceLocatorInterface;use Zend\Mvc\ModuleRouteListener;use Zend\Mvc\MvcEvent;use Zend\ServiceManager\ServiceManager;use Zend\Mail\Transport\Smtp;use Zend\Mail\Transport\SmtpOptions;use Zend\Session\Container;use DGIModule\Acl\Acl;use Zend\Log\Logger;use Zend\Log\Writer;use Zend\Log\Filter;use DGIModule\Processor\LogExtra;use Zend\Validator\AbstractValidator;class Module implements AutoloaderProviderInterface, ConfigProviderInterface{    public function onBootstrap(MvcEvent $e)    {        $eventManager        = $e->getApplication()->getEventManager();        $eventManager->attach('route', array($this, 'onRoute'), -100);        $moduleRouteListener = new ModuleRouteListener();        $moduleRouteListener->attach($eventManager);        $this->setDefaultSessionVariables($e);        $this->initErrorLogger($e);        Type::addType('uuid', 'Ramsey\Uuid\Doctrine\UuidType');    }    public function setDefaultSessionVariables(MvcEvent $e) {        $application = $e->getApplication();        $sm = $application->getServiceManager();        $config = $sm->get('Config');//         unset($_SESSION['guest']);        $levelSession = new Container('level');        if (!$levelSession->level) {            $levelSession->level = 'country';            $levelSession->levelValue = $config['demodyne']['level']['country'];        }    }    public function getConfig()    {        return include __DIR__ . '/config/module.config.php';    }    public function getAutoloaderConfig()    {        return array(            'Zend\Loader\ClassMapAutoloader' => array(                __DIR__ . '/autoload_classmap.php',            ),            'Zend\Loader\StandardAutoloader' => array(                'namespaces' => array(                    __NAMESPACE__ => __DIR__ . '/src/' . __NAMESPACE__,                ),            ),        );    }    public function getServiceConfig()    {        return array(            'abstract_factories' => array(                'Zend\Cache\Service\StorageCacheAbstractServiceFactory',                'Zend\Log\LoggerAbstractServiceFactory',                'Zend\Form\FormAbstractServiceFactory',            ),            'aliases' => array(                'translator' => 'MvcTranslator',            ),            'factories' => array(                'Zend\Authentication\AuthenticationService' => function($serviceManager) {                    return $serviceManager->get('doctrine.authenticationservice.orm_default');                },                'Zend\Log\Logger' => function($sm){                    $logger = new Logger;                    $writer = new Stream(__DIR__.'/../../data/logs/'.date('Y-m-d').'-exception.log');                    $logger->addWriter($writer);                    return $logger;                },                'Navigation' => //'DGIModule\Navigation\DGINavigationFactory',                    function(ServiceManager $sm) {                        $navigation = new DGINavigation();                        return $navigation->createService($sm);                    },                'mail.transport' => function (ServiceManager $serviceManager) {                    $config = $serviceManager->get('Config');                    $transport = new Smtp();                    $transport->setOptions(new SmtpOptions($config['mail']['transport']['options']));                    return $transport;                },                'Zend\Db\Adapter\Adapter'                => 'Zend\Db\Adapter\AdapterServiceFactory',            ),        );    }    public function getLogProcessorConfig()    {        return array(            'factories' => array(                'DGIModule\Processor\LogExtra' => function($sm) {                    $request = $sm->getServiceLocator()->get('Application')->getRequest();                    $processor = new LogExtra($request);                    return $processor;                }            )        );    }    public function getViewHelperConfig()    {        return array(            'factories' => array(                'configItem' => function ($helperPluginManager) {                    $serviceLocator = $helperPluginManager->getServiceLocator();                    $viewHelper = new ConfigItem();                    $viewHelper->setServiceLocator($serviceLocator);                    return $viewHelper;                },                'currentRequest' => function ($helperPluginManager) {                    $viewHelper = new CurrentRequest();                    return $viewHelper;                },                'params' => function (ServiceLocatorInterface $helpers)                {                    $services = $helpers->getServiceLocator();                    $app = $services->get('Application');                    return new View\Helper\Params($app->getRequest(), $app->getMvcEvent());                }            ),        );    }    public function onRoute(MvcEvent $e)    {        $application = $e->getApplication();        $routeMatch = $e->getRouteMatch();        $sm = $application->getServiceManager();        $auth = $sm->get('Zend\Authentication\AuthenticationService');        $config = $sm->get('Config');        $acl = new Acl($config);        // everyone is guest untill it gets logged in        $role = Acl::DEFAULT_ROLE; // The default role is guest $acl        $user = null;        if ($auth->hasIdentity()) {            $user = $auth->getIdentity();            if ($user && $user->getCity()) {                date_default_timezone_set($user->getCity()->getRegion()->getRegionTimezone());            }            else {                date_default_timezone_set('UTC');            }            if ($user) {                $usrl_id = $user->getUsrlId();                $role = array_search($usrl_id, $config['demodyne']['account']['type']);            }        }        $controller = $routeMatch->getParam('controller');        $action = $routeMatch->getParam('action');        if ($user && !$user->getCity() &&            $controller!='DGIModule\Controller\Index' &&            $controller!='DGIModule\Controller\UserRegistration' &&            $controller!='DGIModule\Controller\Location'        ) {            $response = $e->getResponse();            $response->getHeaders()->addHeaderLine('Location', '/');            // The HTTP response status code 302 Found is a common way of performing a redirection.            // http://en.wikipedia.org/wiki/HTTP_302            $response->setStatusCode(302);            $response->sendHeaders();            exit;        }        $request = $sm->get('request');        //print_r($request->getRequestUri());        //var_dump($acl->getRules());        //var_dump($acl->getResources());        if (!$acl->hasResource($controller)) {            throw new \Exception('Resource ' . $controller . ' not defined in the ACL configuration');        }        if (!$acl->isAllowed($role, $controller, $action)) {            $url =  $sm->get('ViewHelperManager')->get('url')->__invoke('home/login', array('action' => 'login'),  array(  'query' => array( 'redirect' => str_replace('#', '-hash-', $request->getRequestUri()))));            $response = $e->getResponse();            $response->getHeaders()->addHeaderLine('Location', $url);            // The HTTP response status code 302 Found is a common way of performing a redirection.            // http://en.wikipedia.org/wiki/HTTP_302            $response->setStatusCode(302);            $response->sendHeaders();            exit;        }        $session = new Container('language');        $availableLanguages = array ('fr', 'en', 'ro');        $defaultLanguage = 'en';        $language = "";        $fromRoute = false;        //see if language could be find in url        if ($e->getApplication()->getRequest()->getQuery('lang')) {            $language = $e->getApplication()->getRequest()->getQuery('lang');            if (in_array($language, $availableLanguages)) {                $session->language = $language;            }            else {                $session->language = $defaultLanguage;            }            $fromRoute = true;        } else {            $headers = $e->getApplication()->getRequest()->getHeaders();            if ($headers->has('Accept-Language') && !$session->language) {                $headerLocale = $headers->get('Accept-Language')->getPrioritized();                $language = substr($headerLocale[0]->getLanguage(), 0,2);                if (in_array($language, $availableLanguages)) {                    $session->language = $language;                }                else {                    $session->language = $defaultLanguage;                }            }            else {                if (!$session->language) {                    $session->language = 'fr';                }            }        }        $language = $session->language;        $locale = $language . '_' . strtoupper($language);        $serviceManager = $e->getApplication()->getServiceManager();        $translator = $serviceManager->get('MvcTranslator');        $translator->setLocale($language);        if ($language == 'ro') {            $formLang = 'en';        }        else {            $formLang = $language;        }        $translator->addTranslationFile(            'phpArray',            getcwd() .'/vendor/zendframework/zend-i18n-resources/languages/'.$formLang.'/Zend_Validate.php'        );        AbstractValidator::setDefaultTranslator($translator);        // Get the default ViewRenderer (PhpRenderer) and setup the correct text domain for derivative plugins        $viewRenderer = $e->getApplication()->getServiceManager()->get('ViewRenderer');        $viewRenderer->plugin('translate')->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formLabel()->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formText()->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formElementErrors()->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formSelect()->setTranslatorTextDomain(__NAMESPACE__);        $detect = new MobileDetect();        if ($detect->isMobile()) {            $_SESSION['mobile'] = true;            $_SESSION['unread'] = 0;            if ($auth->hasIdentity()) {                $entityManager = $sm->get('doctrine.entitymanager.orm_default');                $unreadMessages = $entityManager->getRepository('DGIModule\Entity\Inbox')->findBy(['toUsr'=>$user, 'ibxViewed'=>0, 'ibxToTrashDate'=>null, 'ibxToDeletedDate'=>null]);                $_SESSION['unread'] = count($unreadMessages);            }        }        else {            $_SESSION['mobile'] = false;        }    }        // catch errors and log them    public function initErrorLogger(MvcEvent $e)    {        $app = $e->getApplication();        $eventManager = $app->getEventManager();        $sharedEventManager  = $eventManager->getSharedManager();        $serviceManager = $app->getServiceManager();        // create new logger        $logger = new Logger();        // create priority filter to log only certain error types (warnings or more serious error types).        $filter = new Filter\Priority(Logger::WARN);        // retrieve processor from service manager        $processor = $serviceManager->get('LogProcessorManager')->get('DGIModule\Processor\LogExtra');        // add processor to the logger which will add some extra info (IP, URI, trace) to the final log.        $logger->addProcessor($processor);        //// logging into file ////        // set path of a file where logs will be written to        $filePath = 'data/logs/error.log';        // create new log writer - stream - to log errors to file. Each error will be separated by new line "\n"        $streamWriter = new Stream($filePath, null, "\n");        // add filter to log only warnings or more serious errors        $streamWriter->addFilter($filter);        // add the new writer to logger        $logger->addWriter($streamWriter);        //// logging into db  ////        // get db adapter from service manager        $dbAdapter = $serviceManager->get('Zend\Db\Adapter\Adapter');        // set db table name where logs will be recorded to        $dbTableName = 'dgi_error_log';        // create a map between errors and your db table columns        $map = array(            'timestamp' => 'creation_time',            'priorityName' => 'priority',            'message' => 'message',            'extra' =>  array(                'reference'  => 'reference',                'file'  => 'file',                'line'  => 'line',                'trace' => 'trace',                'xdebug' => 'xdebug',                'uri' => 'uri',                'ip' => 'ip',                'session_id' => 'session_id'            )        );        // create new database writer        $dbWriter = new Writer\Db($dbAdapter, $dbTableName, $map);        // add filter to log only wanted error types        $dbWriter->addFilter($filter);        // add db writer to logger        $logger->addWriter($dbWriter);        // Handle native PHP errors //        // convert php errors into exceptions so that it is caught by same process as framework specific exceptions.        set_error_handler(function ($level, $message, $file, $line) use ($logger) {            $minErrorLevel = error_reporting();            if ($minErrorLevel & $level) {                throw new \ErrorException($message, $code = 0, $level, $file, $line);            }            // return false to not continue native handler            return false;        });        // Handle framework specific errors //        // attach listener to dispatch and render error events        $sharedEventManager->attach('Zend\Mvc\Application', array(MvcEvent::EVENT_DISPATCH_ERROR, MvcEvent::EVENT_RENDER_ERROR), function(MvcEvent $event) use ($logger) {            // check if event is error            if (!$event->isError()) {                return;            }            // get message and exception (if present)            $message = $event->getError();            $exception = $event->getParam('exception');            // generate unique reference for this error            $chars = md5(uniqid('', true));            $errorReference = substr($chars, 2, 2) . substr($chars, 12, 2) . substr($chars, 26, 2);            // add it to logger extra array            $extras = array(                'reference' => $errorReference            );            // check if event has exception and populate extras array.            if (!empty($exception)) {                $message =        $exception->getMessage();                $extras['file'] =  $exception->getFile();                $extras['line']  = $exception->getLine();                $extras['trace'] = $exception->getTraceAsString();                // check if xdebug is enabled and message present in which case add it to the extras as well                if (isset($exception->xdebug_message)) {                    $extra['xdebug'] = $exception->xdebug_message;                }            }            // log it            $priority = Logger::ERR;            $logger->log($priority, $message, $extras);            // hijack skeleton error view and add error reference to the message            $originalMessage = $event->getResult()->getVariable('message');            $event->getResult()->setVariable('message', $originalMessage . '<br /> Error Reference: ' .  $errorReference);        });        // Handle fatal errors //        // catch also fatal errors which woud not show the skeleton error template.        register_shutdown_function(function () use ($logger) {            // get error            $error = error_get_last();            // check and allow only errors            if (null === $error || $error['type'] !== E_ERROR) {                return;            }            // clean any previous output from buffer            while( ob_get_level() > 0 ) {                ob_end_clean();            }            // generate unique reference for this error            $chars = md5(uniqid('', true));            $errorReference = substr($chars, 2, 2) . substr($chars, 12, 2) . substr($chars, 26, 2);            $extras = array(                'reference' => $errorReference,                'file' => $error['file'],                'line' => $error['line']            );            // get priority from logger class            $priority = Logger::$errorPriorityMap[$error['type']];            // log error message and the extra info            $logger->log($priority, $error['message'], $extras);            // set absolute path of the template to render (the shutdown method sometimes changes relative path).            $fatalTemplatePath = __DIR__ . '/view/error/fatal.html';            // read content of file            $body = file_get_contents($fatalTemplatePath);            // inject error reference            $body = str_replace('%__ERROR_REFERENCE__%', 'Error Reference: ' .  $errorReference, $body);            echo $body;            die(1);        });    }}