<?phpnamespace DGIModule;use Zend\ModuleManager\Feature\AutoloaderProviderInterface;use Zend\ModuleManager\Feature\ConfigProviderInterface;use Zend\ModuleManager\Feature\BootstrapListenerInterface;use Zend\ServiceManager\ServiceLocatorInterface;use Zend\Mvc\ModuleRouteListener;use Zend\Mvc\MvcEvent;use Zend\EventManager\EventInterface;use Zend\ServiceManager\ServiceManager;use Zend\Mail\Transport\Smtp;use Zend\Mail\Transport\SmtpOptions;use Zend\Session\Container;use DGIModule\Acl\Acl;use Zend\Validator\AbstractValidator;use Zend\Log\Logger;use Zend\Log\Processor;use Zend\Log\Writer;use Zend\Log\Formatter;use Zend\Log\Filter;use Zend\Db\Adapter;use DGIModule\Processor\LogExtra;class Module implements AutoloaderProviderInterface, ConfigProviderInterface, BootstrapListenerInterface{    public function onBootstrap(EventInterface $e)    {        $eventManager        = $e->getApplication()->getEventManager();        $eventManager->attach('route', array($this, 'onRoute'), -100);        $moduleRouteListener = new ModuleRouteListener();        $moduleRouteListener->attach($eventManager);                $this->setDefaultSessionVariables($e);//         $this->initErrorLogger($e);    }        public function setDefaultSessionVariables($e) {        $application = $e->getApplication();        $sm = $application->getServiceManager();        $config = $sm->get('Config');        $levelSession = new Container('level');        if (!$levelSession->level) {            $levelSession->level = 'country';            $levelSession->levelValue = $config['demodyne']['level']['country'];        }        $auth = $sm->get('Zend\Authentication\AuthenticationService');        $guestSession = new Container('guest');        if (!$auth->hasIdentity() && !$guestSession->country) {            $guestSession->level = 'country';            $guestSession->country = 73;            $guestSession->countryName = 'France';        }    }        public function getConfig()    {        return include __DIR__ . '/config/module.config.php';    }    public function getAutoloaderConfig()    {        return array(            'Zend\Loader\ClassMapAutoloader' => array(                __DIR__ . '/autoload_classmap.php',            ),            'Zend\Loader\StandardAutoloader' => array(                'namespaces' => array(                    __NAMESPACE__ => __DIR__ . '/src/' . __NAMESPACE__,                ),            ),        );    }        public function getServiceConfig()    {        return array(            'abstract_factories' => array(                'Zend\Cache\Service\StorageCacheAbstractServiceFactory',                'Zend\Log\LoggerAbstractServiceFactory',                'Zend\Form\FormAbstractServiceFactory',            ),            'aliases' => array(                'translator' => 'MvcTranslator',            ),          'factories' => array(                'Zend\Authentication\AuthenticationService' => function($serviceManager) {                    return $serviceManager->get('doctrine.authenticationservice.orm_default');                },                'Zend\Log\Logger' => function($sm){                    $logger = new Zend\Log\Logger;                    $writer = new Zend\Log\Writer\Stream(__DIR__.'/../../data/logs/'.date('Y-m-d').'-exception.log');                                        $logger->addWriter($writer);                                        return $logger;                },                'Navigation' => '\DGIModule\Navigation\DGINavigationFactory',                'mail.transport' => function (ServiceManager $serviceManager) {                    $config = $serviceManager->get('Config');                    $transport = new Smtp();                    $transport->setOptions(new SmtpOptions($config['mail']['transport']['options']));                    return $transport;                },                'Zend\Db\Adapter\Adapter'                    => 'Zend\Db\Adapter\AdapterServiceFactory',            ),                );    }        public function getLogProcessorConfig()    {        return array(            'factories' => array(                'DGIModule\Processor\LogExtra' => function($sm) {                $request = $sm->getServiceLocator()->get('Application')->getRequest();                $processor = new LogExtra($request);                return $processor;                }                )            );    }            public function getViewHelperConfig()    {        return array(            'factories' => array(                'configItem' => function ($helperPluginManager) {                    $serviceLocator = $helperPluginManager->getServiceLocator();                    $viewHelper = new \DGIModule\View\Helper\ConfigItem();                    $viewHelper->setServiceLocator($serviceLocator);                    return $viewHelper;                },                'Params' => function (ServiceLocatorInterface $helpers)                {                    $services = $helpers->getServiceLocator();                    $app = $services->get('Application');                    return new View\Helper\Params($app->getRequest(), $app->getMvcEvent());                }            ),        );    }    // WORKING the main engine for ACL    public function onRoute(\Zend\EventManager\EventInterface $e) // Event manager of the app    {        $application = $e->getApplication();        $routeMatch = $e->getRouteMatch();        $sm = $application->getServiceManager();        $auth = $sm->get('Zend\Authentication\AuthenticationService');        $config = $sm->get('Config');        $acl = new Acl($config);        // everyone is guest untill it gets logged in        $role = Acl::DEFAULT_ROLE; // The default role is guest $acl        if ($auth->hasIdentity()) {            $usr = $auth->getIdentity();            $usrl_id = $usr->getUsrlId(); // Use a view to get the name of the role            switch ($usrl_id) {                case 1 :                    $role = Acl::DEFAULT_ROLE; // guest                    break;                case 2 :                    $role = 'member';                    break;                case 3 :                    $role = 'partner';                    break;                case 4 :                    $role = 'administration';                    break;                case 5 :                    $role = 'admin';                    break;                default :                    $role = Acl::DEFAULT_ROLE; // guest                    break;            }        }        $controller = $routeMatch->getParam('controller');        $action = $routeMatch->getParam('action');        $request = $sm->get('request');        if (!$acl->hasResource($controller)) {            throw new \Exception('Resource ' . $controller . ' not defined in the ACL configuration');        }        if (!$acl->isAllowed($role, $controller, $action)) {            $url =  $sm->get('ViewHelperManager')->get('url')->__invoke('home/login', array('action' => 'login'),  array(  'query' => array( 'redirect' => $request->getRequestUri())));            $response = $e->getResponse();            $response->getHeaders()->addHeaderLine('Location', $url);            // The HTTP response status code 302 Found is a common way of performing a redirection.            // http://en.wikipedia.org/wiki/HTTP_302            $response->setStatusCode(302);            $response->sendHeaders();            exit;        }        $session = new Container('language');        $availableLanguages = array ('fr', 'en');        $defaultLanguage = 'en';        $language = "";        $fromRoute = false;        //see if language could be found in url        if ($e->getApplication()->getRequest()->getQuery('lang')) {            $language = $e->getApplication()->getRequest()->getQuery('lang');            if (in_array($language, $availableLanguages)) {                $session->language = $language;            }            else {                $session->language = $defaultLanguage;            }            $fromRoute = true;             //or use language from http accept        } else {            $headers = $e->getApplication()->getRequest()->getHeaders();            if ($headers->has('Accept-Language') && !$session->language) {                $headerLocale = $headers->get('Accept-Language')->getPrioritized();                $language = substr($headerLocale[0]->getLanguage(), 0,2);                if (in_array($language, $availableLanguages)) {                    $session->language = $language;                }                else {                    $session->language = $defaultLanguage;                }            }            else {                if (!$session->language) {                    $session->language = 'fr';                }                            }        }        $language = $session->language;        $locale = $language . '_' . strtoupper($language);        $serviceManager = $e->getApplication()->getServiceManager();        $translator = $serviceManager->get('MvcTranslator');        $translator->setLocale($language);        $translator->addTranslationFile(            'phpArray',            getcwd() .'/vendor/zendframework/zend-i18n-resources/languages/'.$language.'/Zend_Validate.php'            );        \Zend\Validator\AbstractValidator::setDefaultTranslator($translator);        // Get the default ViewRenderer (PhpRenderer) and setup the correct text domain for derivative plugins        $viewRenderer = $e->getApplication()->getServiceManager()->get('ViewRenderer');        $viewRenderer->plugin('translate')->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formLabel()->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formText()->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formElementErrors()->setTranslatorTextDomain(__NAMESPACE__);        $viewRenderer->formSelect()->setTranslatorTextDomain(__NAMESPACE__);    }        // catch errors and log them    public function initErrorLogger($e)    {        $app = $e->getApplication();        $eventManager = $app->getEventManager();        $sharedEventManager  = $eventManager->getSharedManager();        $serviceManager = $app->getServiceManager();                // create new logger        $logger = new Logger();        // create priority filter to log only certain error types (warnings or more serious error types).        $filter = new Filter\Priority(Logger::WARN);                // retrieve processor from service manager        $processor = $serviceManager->get('LogProcessorManager')->get('DGIModule\Processor\LogExtra');        // add processor to the logger which will add some extra info (IP, URI, trace) to the final log.        $logger->addProcessor($processor);                    //// logging into file ////            // set path of a file where logs will be written to        $filePath = 'data/logs/error.log';        // create new log writer - stream - to log errors to file. Each error will be separated by new line "\n"        $streamWriter = new Writer\Stream($filePath, null, "\n");        // add filter to log only warnings or more serious errors        $streamWriter->addFilter($filter);        // add the new writer to logger        $logger->addWriter($streamWriter);                //// logging into db (delete this section if logging in to file is good enough)  ////            // get db adapter from service manager        $dbAdapter = $serviceManager->get('Zend\Db\Adapter\Adapter');        // set db table name where logs will be recorded to        $dbTableName = 'dgi_error_log';            // create a map between errors and your db table columns        $map = array(            'timestamp' => 'creation_time',            'priorityName' => 'priority',            'message' => 'message',            'extra' =>  array(                'reference'  => 'reference',                'file'  => 'file',                'line'  => 'line',                'trace' => 'trace',                'xdebug' => 'xdebug',                'uri' => 'uri',                'ip' => 'ip',                'session_id' => 'session_id'            )        );            // create new database writer        $dbWriter = new Writer\Db($dbAdapter, $dbTableName, $map);        // add filter to log only wanted error types        $dbWriter->addFilter($filter);        // add db writer to logger        $logger->addWriter($dbWriter);                // Handle native PHP errors //            // convert php errors into exceptions so that it is caught by same process as framework specific exceptions.        set_error_handler(function ($level, $message, $file, $line) use ($logger) {            $minErrorLevel = error_reporting();            if ($minErrorLevel & $level) {                throw new \ErrorException($message, $code = 0, $level, $file, $line);            }            // return false to not continue native handler            return false;        });                // Handle framework specific errors //            // attach listener to dispatch and render error events            $sharedEventManager->attach('Zend\Mvc\Application', array(MvcEvent::EVENT_DISPATCH_ERROR, MvcEvent::EVENT_RENDER_ERROR), function($event) use ($logger) {                // check if event is error                if (!$event->isError()) {                    return;                }                // get message and exception (if present)                $message = $event->getError();                $exception = $event->getParam('exception');                // generate unique reference for this error                $chars = md5(uniqid('', true));                $errorReference = substr($chars, 2, 2) . substr($chars, 12, 2) . substr($chars, 26, 2);                // add it to logger extra array                $extras = array(                    'reference' => $errorReference                );                // check if event has exception and populate extras array.                if (!empty($exception)) {                    $message =        $exception->getMessage();                    $extras['file'] =  $exception->getFile();                    $extras['line']  = $exception->getLine();                    $extras['trace'] = $exception->getTraceAsString();                        // check if xdebug is enabled and message present in which case add it to the extras as well                    if (isset($exception->xdebug_message)) {                        $extra['xdebug'] = $exception->xdebug_message;                    }                }                    // log it                $priority = Logger::ERR;                $logger->log($priority, $message, $extras);                    // hijack skeleton error view and add error reference to the message                $originalMessage = $event->getResult()->getVariable('message');                $event->getResult()->setVariable('message', $originalMessage . '<br /> Error Reference: ' .  $errorReference);                });                        // Handle fatal errors //                    // catch also fatal errors which woud not show the skeleton error template.                register_shutdown_function(function () use ($logger) {                    // get error                    $error = error_get_last();                    // check and allow only errors                    if (null === $error || $error['type'] !== E_ERROR) {                        return;                    }                        // clean any previous output from buffer                    while( ob_get_level() > 0 ) {                        ob_end_clean();                    }                        // generate unique reference for this error                    $chars = md5(uniqid('', true));                    $errorReference = substr($chars, 2, 2) . substr($chars, 12, 2) . substr($chars, 26, 2);                        $extras = array(                        'reference' => $errorReference,                        'file' => $error['file'],                        'line' => $error['line']                    );                        // get priority from logger class                    $priority = Logger::$errorPriorityMap[$error['type']];                    // log error message and the extra info                    $logger->log($priority, $error['message'], $extras);                        // set absolute path of the template to render (the shutdown method sometimes changes relative path).                    $fatalTemplatePath = __DIR__ . '/view/error/fatal.html';                        // read content of file                    $body = file_get_contents($fatalTemplatePath);                    // inject error reference                    $body = str_replace('%__ERROR_REFERENCE__%', 'Error Reference: ' .  $errorReference, $body);                    echo $body;                    die(1);                });    }}